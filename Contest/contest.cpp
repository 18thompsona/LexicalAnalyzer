/* front.c - a lexical analyzer system for simple
arithmetic expressions */
#include <stdio.h>
#include <ctype.h>
#include <stdlib.h>
#include <string.h>

using namespace std;

/* Global declarations */
/* Variables */
int charClass;
char lexeme[100];
char nextChar;
int lexLen;
int token;
int nextToken;
FILE *in_fp, *fopen();

/* Function declarations */
void addChar();
void getChar();
void getNonBlank();
int lex();
void S();
void A();
void B();
void C();

/* Character classes */
#define LETTER 0
#define DIGIT 1
#define UNKNOWN 99

/* Token codes */
#define INT_LIT 10
#define IDENT 11
#define ASSIGN_OP 20
#define ADD_OP 21
#define SUB_OP 22
#define MULT_OP 23
#define DIV_OP 24
#define LEFT_PAREN 25
#define RIGHT_PAREN 26
#define IDEN_a 30
#define IDEN_b 31
#define IDEN_c 32

/******************************************************/
/* main driver */
int main()
{
    /* Open the input data file and process its contents */
    if ((in_fp = fopen("contest.in", "r")) == NULL)
        printf("ERROR - cannot open contest.in \n");
    else
    {
        getChar();
        do
        {
            lex();
            S();
        } while (nextToken != EOF);
    }
}

/*****************************************************/
/* addChar - a function to add nextChar to lexeme */
void addChar()
{
    if (lexLen <= 98)
    {
        lexeme[lexLen++] = nextChar;
        lexeme[lexLen] = 0;
    }
    else
    {
        printf("Error - lexeme is too long \n");
    }
}

/*****************************************************/
/* getChar - a function to get the next character of
input and determine its character class */
void getChar()
{
    if ((nextChar = getc(in_fp)) != EOF)
    {
        if (isalpha(nextChar))
        {
            charClass = LETTER;
        }
        else
        {
            charClass = UNKNOWN;
        }
    }
    else
    {
        charClass = EOF;
    }
}

/*****************************************************/
/* getNonBlank - a function to call getChar until it
returns a non-whitespace character */
void getNonBlank()
{
    while (isspace(nextChar))
    {
        getChar();
    }
}

/***************************************************** /
    /* lex - a simple lexical analyzer for arithmetic
    expressions */
int lex()
{
    lexLen = 0;
    getNonBlank();
    
    switch (charClass)
    {
    /* Parse identifiers */
    case LETTER:
        addChar();
        getChar();
        printf("%s\n",lexeme);

        if (lexeme[0] == 'a')
        {
            printf("in a\n");
            nextToken = IDEN_a;
        }
        else if (lexeme[0] == 'b')
        {
            printf("in b\n");
            nextToken = IDEN_b;
        }
        else if (lexeme[0] == 'c')
        {
            printf("in c\n");
            nextToken = IDEN_c;
        }
        break;
    //Case UNKNOWN
    case UNKNOWN:
        printf("Error, Not Possible\n");
        exit(0);
        break;
    /* EOF */
    case EOF:
        nextToken = EOF;
        lexeme[0] = 'E';
        lexeme[1] = 'O';
        lexeme[2] = 'F';
        lexeme[3] = 0;
        break;
    } /* End of switch */

    printf("Next token is: %d, Next lexeme is %s\n", nextToken, lexeme);
    return nextToken;
} /* End of function lex */

// /* expr
// Parses strings in the language generated by the rule:
// <expr> -> <term> {(+ | -) <term>}
// */
// void expr()
// {
//     printf("Enter <expr>\n");
//     /* Parse the first term */
//     term();
//     /* As long as the next token is + or -, get
//     the next token and parse the next term */
//     while (nextToken == ADD_OP || nextToken == SUB_OP)
//     {
//         lex();
//         term();
//     }
//     printf("Exit <expr>\n");
// } /* End of function expr */

// /* term
// Parses strings in the language generated by the rule:
// <term> -> <factor> {(* | /) <factor>)
// */
// void term()
// {
//     printf("Enter <term>\n");
//     /* Parse the first factor */
//     factor();
//     /* As long as the next token is * or /, get the
//     next token and parse the next factor */
//     while (nextToken == MULT_OP || nextToken == DIV_OP)
//     {
//         lex();
//         factor();
//     }
//     printf("Exit <term>\n");
// } /* End of function term */

// /* factor
// Parses strings in the language generated by the rule:
// <factor> -> id | int_constant | ( <expr )
// */
// void factor()
// {
//     printf("Enter <factor>\n");
//     /* Determine which RHS */
//     if (nextToken == IDENT || nextToken == INT_LIT)
//         /* Get the next token */
//         lex();
//     /* If the RHS is ( <expr>), call lex to pass over the
//     left parenthesis, call expr, and check for the right
//     parenthesis */
//     else
//     {
//         if (nextToken == LEFT_PAREN)
//         {
//             lex();
//             expr();
//             if (nextToken == RIGHT_PAREN)
//                 lex();
//             else
//                 printf("error\n");
//         } /* End of if (nextToken == ... */
//         /* It was not an id, an integer literal, or a left
//         parenthesis */
//         else
//             printf("error\n");
//     } /* End of else */
//     printf("Exit <factor>\n");
//     ;
// } /* End of function factor */

//S -> A
void S()
{
    printf("Enter <S>\n");

    A();
    while (nextToken != EOF)
    {
        lex();
        A();
    }

    printf("Exit <S>\n");
}


//A -> a | aA | B 
void A()
{
    printf("Enter <A>\n");

    if ((lexeme[0] == 'a') && (nextChar = getc(in_fp) == 'a'))
    {
        lex();
        A();
    }
    else if (nextChar != 'a' && lexeme[0] == 'a')
    {
        printf("Print A\n");
        return;
    }
    else
    {
        B();
    }
    
    printf("Exit <A>\n");
}

//B -> b | bbB | C
void B()
{
    printf("Enter <B>\n");

    if ((lexeme[0] == 'b') && (nextChar = getc(in_fp) == 'b'))
    {
        lex();
        B();
    }
    else if (lexeme[0] == 'b')
    {
        printf("Exit <B>\n");
        exit(0);
    }
    else
    {
        C();
    }
    
    printf("Exit <B>\n");
}

//C -> cc | cCc
void C()
{
    printf("Enter <C>\n");

    if ((lexeme[0] == 'c') && (nextChar = getc(in_fp) == 'c'))
    {
        lex();
        C();
    }
    else
    {
        return;
    }
    

    printf("Exit <C>\n");
}